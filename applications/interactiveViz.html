<!DOCTYPE html>
<html lang="en">
<head>
	<title>Conflict Urbanism: Colombia</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<script type="text/javascript" src="../js/three.js"></script>
	<script type="text/javascript" src="../js/Detector.js"></script>
	<script type="text/javascript" src="../js/stats.min.js"></script>
	<script type="text/javascript" src="../js/tween.min.js"></script>
	<script type="text/javascript" src="../js/d3.js"></script>
	<script type="text/javascript" src="https://d3js.org/d3-queue.v3.min.js"></script>
	<!-- Custom stuyles -->
	<link rel="stylesheet" type="text/css" href="../css/interactive_visualization.css">
	<!-- Google fonts -->
	<link href="https://fonts.googleapis.com/css?family=Roboto:100,300,300i,400,700" rel="stylesheet">
</head>

<body>
	<!-- Title Text and Header -->
	<div id="victimTitle">
		<p><span id="titleText">Victims</span> A random sample of 200,000 victims of the conflict</p>
	</div>
	<div id="legends">
		<div id="legend01">
			<p><span id="legend01Text"></span></p>
		</div>
		<div id="legendRect01"></div>
		<div id="legend02">
			<p><span id="legend02Text"></span></p>
		</div>
		<div id="legendRect02"></div>
		<div id="legend03">
			<p><span id="legend03Text"></span></p>
		</div>
		<div id="legendRect03"></div>
		<div id="legend04">
			<p><span id="legend04Text"></span></p>
		</div>
		<div id="legendRect04"></div>
	</div>

	<!-- Divs to sort and color data. D3 listens to these divs and updates GL once they are clicked -->
	<div class="button sort" style="background-color: #202323" id="sortTitle">
		<p id="buttonText">Order</p>
	</div>
	<div class="button sort" id="sortKey">
		<p id="buttonText">Key</p>
	</div>
	<div class="button sort" id="sortHecho">
		<p id="buttonText">Event</p>
	</div>
	<div class="button sort" id="sortActor">
		<p id="buttonText">Actor</p>
	</div>
	<div class="button sort" id="sortGender">
		<p id="buttonText">Gender</p>
	</div>
	<div class="button sort" id="sortRace">
		<p id="buttonText">Race</p>
	</div>
	<div class="button sort" id="sortEventDate">
		<p id="buttonText">Event Date</p>
	</div>
	<div class="button sort" id="sortReportDate">
		<p id="buttonText">Report Date</p>
	</div>

	<!-- Divs to color -->
	<div class="button color" style="background-color: #202323" id="colorTitle">
		<p id="buttonText">Color</p>
	</div>
	<div class="button color" id="colorKey">
		<p id="buttonText">Key</p>
	</div>
	<div class="button color" id="colorHecho">
		<p id="buttonText">Event</p>
	</div>
	<div class="button color" id="colorActor">
		<p id="buttonText">Actor</p>
	</div>
	<div class="button color" id="colorGender">
		<p id="buttonText">Gender</p>
	</div>
	<div class="button color" id="colorRace">
		<p id="buttonText">Race</p>
	</div>
	<div class="button color" id="colorEventDate">
		<p id="buttonText">Event Date</p>
	</div>
	<div class="button color" id="colorReportDate">
		<p id="buttonText">Report Date</p>
	</div>
	
	<div id="tooltip" class="hidden">
		<p><span id="dateText">100</span></p>
		<p><span id="eventText">100</span></p>
		<p><span id="actorText">100</span></p>
		<p><span id="genderText">100</span></p>
		<p><span id="ethnicityText">100</span></p>
	</div>

	<script>
		// ########################## JAVASCRIPT + THREE.JS ############################
		// Webgl error message
		if ( ! Detector.webgl ) Detector.addGetWebGLMessage(); 
		// ############################# GLOBAL VARIABLES ##############################
		var container, stats;
		var fieldGeom, camera, scene, renderer, raycaster, particles, geometry, materials = [], colors = [], parameters, i, h, color, size;
		var clock = new THREE.Clock();
		var viewSize, aspectRatio, myWidth, myHeight;
		var needUpdate = false;
		var duration = currentTime = 3;
		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;
		// Setup view settings
		viewSize = 900;
		aspectRatio = window.innerWidth / window.innerHeight;	//SQUASH BUG HERE!!!
		myHeight = viewSize;
		myWidth = parseInt(viewSize*aspectRatio);
		var dataPadding = 60;
		// For best viewing on my display, 1:3 ratio
		var rectSize = 1; //1
		var rectSpacerW = rectSpacerH = 1; //3
		var mouse = new THREE.Vector2();
		var threshold = rectSpacerW*2;
		var sphere;
		var raycastOn;
		var buttonColorOn = "#d3d3d3";
		var buttonColorOff = "#2f4f4f";
		var myFileDataPath = "data/200k_opened_correct_wcs_nocomma_OUTPUT.csv";
		//Victims dataset
		var datasetVictims = [];
		//Timeline dataset
		var eventTimeline = [ [0, '1985'], [477, '1986'], [1076, '1987'], [1778, '1988'], [2916, '1989'], [4031, '1990'], [5451, '1991'], [6867, '1992'], [8534, '1993'], [10351, '1994'], [12259, '1995'], [15327, '1996'], [19128, '1997'], [25613, '1998'], [31744, '1999'], [38960, '2000'], [53078, '2001'], [69698, '2002'], [89011, '2003'], [101207, '2004'], [112106, '2005'], [123391, '2006'], [134525, '2007'], [146208, '2008'], [156291, '2009'], [162501, '2010'], [167786, '2011'], [174592, '2012'], [182330, '2013'], [190085, '2014'], [197012, '2015'] ];
		var reportTimeline = [ [0, ''], [11, '1990'], [18, '1993'], [19, '1994'], [20, '1996'], [79, '1997'], [423, '1998'], [1713, '1999'], [2834, '2000'], [10129, '2001'], [20233, '2002'], [32689, '2003'], [39577, '2004'], [46517, '2005'], [54223, '2006'], [62978, '2007'], [73698, '2008'], [91335, '2009'], [105601, '2010'], [115881, '2011'], [126337, '2012'], [144304, '2013'], [166458, '2014'], [188663, '2015'], [199998, '2016'] ];
		if(viewSize == 800) {
			var hardCodeTimelineMin = 78;
			var hardCodeTimelineMax = 942;
		} else{
			var hardCodeTimelineMin = 35;
			var hardCodeTimelineMax = 985;
		}
		var hardCodeDataLen = 200000;
		var timelineTagMod = 2;
		//Create as many timeline date events as there are data
		d3.select("body").selectAll(".timeline#event")
		.data(eventTimeline)
		.enter()
		.append('div')
		.attr('class', 'timeline')
		.attr('id', 'event')
		.style('left', function(d,i){
			var canvasX = getXYCoordinates(d[0], myWidth, myHeight)[0];
			canvasX = map_range(canvasX, getXYCoordinates(0, myWidth, myHeight)[0], getXYCoordinates(hardCodeDataLen, myWidth, myHeight)[0], hardCodeTimelineMin, hardCodeTimelineMax);
			return canvasX+"px";
		})
		.append('p')
		.attr('id', 'timelineText')
		.text(function(d){
			if(parseInt(d[1]) != 1988) {
				if (parseInt(d[1])%timelineTagMod ==0){
					return d[1];
				}
			}
		});
		//Create tick marks
		d3.select("body").selectAll('.timelineTick#event')
		.data(eventTimeline)
		.enter()
		.append('div')
		.attr('class', 'timelineTick')
		.attr('id', 'event')
		.style('left', function(d,i){
			var canvasX = getXYCoordinates(d[0], myWidth, myHeight)[0];
			canvasX = map_range(canvasX, getXYCoordinates(0, myWidth, myHeight)[0], getXYCoordinates(hardCodeDataLen, myWidth, myHeight)[0], hardCodeTimelineMin, hardCodeTimelineMax);
			return canvasX+"px";
		});
		//Create as many timeline reported dates as there are data
		d3.select("body").selectAll(".timeline#report")
		.data(reportTimeline)
		.enter()
		.append('div')
		.attr('class', 'timeline')
		.attr('id', 'report')
		.style('left', function(d,i){
			var canvasX = getXYCoordinates(d[0], myWidth, myHeight)[0];
			canvasX = map_range(canvasX, getXYCoordinates(0, myWidth, myHeight)[0], getXYCoordinates(hardCodeDataLen, myWidth, myHeight)[0], hardCodeTimelineMin, hardCodeTimelineMax);
			return canvasX+"px";
		})
		.append('p')
		.attr('id', 'timelineText')
		.text(function(d){
					if (parseInt(d[1]) != 1998 && parseInt(d[1]) != 1996 && parseInt(d[1]) != 1994) {						//1998 and 1996 overlaps so we hide it
						if (parseInt(d[1])%timelineTagMod ==0){
							return d[1];
						}
					}
				});
		//Create tick marks
		d3.select("body").selectAll('.timelineTick#report')
		.data(reportTimeline)
		.enter()
		.append('div')
		.attr('class', 'timelineTick')
		.attr('id', 'report')
		.style('left', function(d,i){
			var canvasX = getXYCoordinates(d[0], myWidth, myHeight)[0];
			canvasX = map_range(canvasX, getXYCoordinates(0, myWidth, myHeight)[0], getXYCoordinates(hardCodeDataLen, myWidth, myHeight)[0], hardCodeTimelineMin, hardCodeTimelineMax);
			return canvasX+"px";
		});
		//Hide the timelines
		d3.selectAll(".timeline").classed("hidden", true);
		//Hide the timeline tick marks
		d3.selectAll(".timelineTick").classed("hidden", true);
		//Run our script, this function and d3 prevent viz from running before data is fully loaded
		parseMyFile(myFileDataPath);

		// #############################################################################
		// ###### Parses data and establishes queue to load data before viz is run #####
		// #############################################################################

		function parseMyFile(myFileName) {
			var q = d3.queue();
			q.defer(function(callback) {
				d3.csv(myFileName, function(res) {
					//By default, csv loads all data as strings, here we parse the data into other data types
					res.forEach(function(d,i) {
						d.key = i;							//we also add a temporary key value
						d.cod_persona = +d.cod_persona;
						d.param_hecho = +d.param_hecho;
						d.uniqueRank_param_hecho = +d.uniqueRank_param_hecho;
						d.uniqueRank_pert_etnica = +d.uniqueRank_pert_etnica;
						d.uniqueRank_genero_hom = +d.uniqueRank_genero_hom;
						d.uniqueRank_event_date = +d.uniqueRank_event_date;
						d.uniqueRank_actors = +d.uniqueRank_actors;
						d.uniqueRank_report_date = +d.uniqueRank_report_date;
						//Reclassifying race data col
						if (d.pert_etnica == "Negro(a) o Afrocolombiano(a)") {
							d.pert_etnica = "Afrocolombian";
						}
						else if (d.pert_etnica == "Gitano(a) ROM") {
							d.pert_etnica = "ROM";
						}
						else if (d.pert_etnica == "Indigena") {
							d.pert_etnica = "Indigenous";
						}
						else if (d.pert_etnica == "Palenquero") {
							d.pert_etnica = "Palenquero"
						}
						else if (d.pert_etnica == "Raizal del Archipielago de San Andres y Providencia") {
							d.pert_etnica = "San Andres Providencia";
						}
						else {
							d.pert_etnica = "None";
						}
						d.thisColor = [0,0,0];
					});
					//Passes data to the queue once we have loaded datat
					callback(null, res);
				});
			});
			//Once data has loaded, execute rest of code
			q.await(restOfCode);
		};

		// #############################################################################
		// ################# AFTER DATA HAS LOADED, RUN THE REST #######################
		// #############################################################################

		function restOfCode(err, results) {
			// Set dataset to the data d3 just loaded in the queue
			datasetVictims = results;
			var dataSetLen = datasetVictims.length;
			// Three JS functions to first initialize and then animate the scene
			init();
			animate();

			// #############################################################
			// ################# D3 div Click Events #######################
			// #############################################################

			// ### Sorting events ###

			//D3 to Handle click events on sorting our divs
			//d3 listens for when our divs are clicked and then prompts the animation to reset
			d3.select("#sortKey").on("click", function() {
				// Tell Three JS that we need to update the animation
				resetAnimation();
				// Update the 3vectors for all of the particles loaded
				// Each particle has an associated vector, the intial position being the current position of the particle and
				// the final positoin being the indexed XY coordinate of the particle depending on which sort the user has picked
				// Using a timer that is reset each time one of thee sorts is clicked, the animation moves the particle in a straight line
				// from the initial to the final position by multiplying the vector between the two points by 1/(time left in transition
				// animation). Here, for each particle we simply update the start position to the particles current position, the end
				// position to be the user specified sort XY coordinate, and the direction to be the vector b/w those two points.
				// The particles are moved along these vectors in the animate portion of the code.
				for (i = 0; i < dataSetLen; i ++){
					var thisDataPt = datasetVictims[i];
					// Make sure the start position is the current 3vector
					var start3Vector = new THREE.Vector3(geometry.vertices[i].x, geometry.vertices[i].y, geometry.vertices[i].z);	
					// Find the new desired XY coordinates	
					var newXY = getXYCoordinates(thisDataPt.key, myWidth, myHeight);
					var end3Vector = new THREE.Vector3(newXY[0], newXY[1], 0);
					// Compute the vector between these two points
					geometry.vertices[i].startPosition = start3Vector;
					geometry.vertices[i].endPosition = end3Vector;
					geometry.vertices[i].direction = start3Vector.clone().sub(end3Vector);
				}
				updateUiSortKey();
			});
			d3.select("#sortHecho").on("click", function() {
				resetAnimation();
				//Update the 3vectors for all of the particles loaded
				for (i = 0; i < dataSetLen; i ++){
					var thisDataPt = datasetVictims[i];
					var start3Vector = new THREE.Vector3(geometry.vertices[i].x, geometry.vertices[i].y, geometry.vertices[i].z);
					var newXY = getXYCoordinates(thisDataPt.uniqueRank_param_hecho, myWidth, myHeight);
					var end3Vector = new THREE.Vector3(newXY[0], newXY[1], 0);
					geometry.vertices[i].startPosition = start3Vector;
					geometry.vertices[i].endPosition = end3Vector;
					geometry.vertices[i].direction = start3Vector.clone().sub(end3Vector);
				}
				updateUiSortHecho();
			});
			d3.select("#sortActor").on("click", function() {
				resetAnimation();
				//Update the 3vectors for all of the particles loaded
				for (i = 0; i < dataSetLen; i ++){
					var thisDataPt = datasetVictims[i];
					var start3Vector = new THREE.Vector3(geometry.vertices[i].x, geometry.vertices[i].y, geometry.vertices[i].z);
					var newXY = getXYCoordinates(thisDataPt.uniqueRank_actors, myWidth, myHeight);
					var end3Vector = new THREE.Vector3(newXY[0], newXY[1], 0);
					geometry.vertices[i].startPosition = start3Vector;
					geometry.vertices[i].endPosition = end3Vector;
					geometry.vertices[i].direction = start3Vector.clone().sub(end3Vector);
				}
				updateUiSortActor();
			});
			d3.select("#sortGender").on("click", function() {
				resetAnimation();
				//Update the 3vectors for all of the particles loaded
				for (i = 0; i < dataSetLen; i ++){
					var thisDataPt = datasetVictims[i];
					var start3Vector = new THREE.Vector3(geometry.vertices[i].x, geometry.vertices[i].y, geometry.vertices[i].z);
					var newXY = getXYCoordinates(thisDataPt.uniqueRank_genero_hom, myWidth, myHeight);
					var end3Vector = new THREE.Vector3(newXY[0], newXY[1], 0);
					geometry.vertices[i].startPosition = start3Vector;
					geometry.vertices[i].endPosition = end3Vector;
					geometry.vertices[i].direction = start3Vector.clone().sub(end3Vector);
				}
				updateUiSortGender();
			});
			d3.select("#sortRace").on("click", function() {
				resetAnimation();
				//Update the 3vectors for all of the particles loaded
				for (i = 0; i < dataSetLen; i ++){
					var thisDataPt = datasetVictims[i];
					var start3Vector = new THREE.Vector3(geometry.vertices[i].x, geometry.vertices[i].y, geometry.vertices[i].z);
					var newXY = getXYCoordinates(thisDataPt.uniqueRank_pert_etnica, myWidth, myHeight);
					var end3Vector = new THREE.Vector3(newXY[0], newXY[1], 0);
					geometry.vertices[i].startPosition = start3Vector;
					geometry.vertices[i].endPosition = end3Vector;
					geometry.vertices[i].direction = start3Vector.clone().sub(end3Vector);
				}
				updateUiSortRace();
			});
			d3.select("#sortEventDate").on("click", function() {
				resetAnimation();
				//Update the 3vectors for all of the particles loaded
				for (i = 0; i < dataSetLen; i ++){
					var thisDataPt = datasetVictims[i];
					var start3Vector = new THREE.Vector3(geometry.vertices[i].x, geometry.vertices[i].y, geometry.vertices[i].z);
					var newXY = getXYCoordinates(thisDataPt.uniqueRank_event_date, myWidth, myHeight);
					var end3Vector = new THREE.Vector3(newXY[0], newXY[1], 0);
					geometry.vertices[i].startPosition = start3Vector;
					geometry.vertices[i].endPosition = end3Vector;
					geometry.vertices[i].direction = start3Vector.clone().sub(end3Vector);
				}
				updateUiSortEventDate();
			});
			d3.select("#sortReportDate").on("click", function() {
				resetAnimation();
				//Update the 3vectors for all of hte particles loaded
				for (i = 0; i < dataSetLen; i ++){
					var thisDataPt = datasetVictims[i];
					var start3Vector = new THREE.Vector3(geometry.vertices[i].x, geometry.vertices[i].y, geometry.vertices[i].z);
					var newXY = getXYCoordinates(thisDataPt.uniqueRank_report_date, myWidth, myHeight);
					var end3Vector = new THREE.Vector3(newXY[0], newXY[1], 0);
					geometry.vertices[i].startPosition = start3Vector;
					geometry.vertices[i].endPosition = end3Vector;
					geometry.vertices[i].direction = start3Vector.clone().sub(end3Vector);
				}
				updateUiSortReportDate();
			});
			// ### Color Events ###
			d3.select("#colorKey").on("click", function() {
				//Update colors of the particles
				for (i = 0; i < dataSetLen; i ++){
					var thisDataPt = datasetVictims[i];
					geometry.colors[i] = colorKey(thisDataPt);
				}
				updateUiColorKey();
			});
			d3.select("#colorHecho").on("click", function() {
				//Update colors of the particles
				for (i = 0; i < dataSetLen; i ++){
					var thisDataPt = datasetVictims[i];
					geometry.colors[i] = colorHecho(thisDataPt);
				}
				updateUiColorHecho();
			});
			d3.select("#colorActor").on("click", function() {
				//Update colors of the particles
				for (i = 0; i < dataSetLen; i ++){

					var thisDataPt = datasetVictims[i];
					geometry.colors[i] = colorActor(thisDataPt);
				}
				updateUiColorActor();
			});
			d3.select("#colorGender").on("click", function() {
				//Update colors of the particles
				for (i = 0; i < dataSetLen; i ++){
					var thisDataPt = datasetVictims[i];
					geometry.colors[i] = colorGender(thisDataPt);
				}
				updateUiColorGender();
			});
			d3.select("#colorRace").on("click", function() {
				//Update colors of the particles
				for (i = 0; i < dataSetLen; i ++){
					var thisDataPt = datasetVictims[i];
					geometry.colors[i] = colorRace(thisDataPt);
				}
				updateUiColorRace();
			});
			//Optional color by event date for date color
			d3.select("#colorEventDate").on("click", function() {
				// Update colors of the particles
				for (i = 0; i < dataSetLen; i ++){
					var thisDataPt = datasetVictims[i];
					geometry.colors[i] = colorEventDate(thisDataPt);
				}
				// UPDATE UI HERE
				updateUiColorEventDate();

			});
			//Optional color by report date for date color
			d3.select("#colorReportDate").on("click", function() {
				// Update colors of the particles
				for (i = 0; i < dataSetLen; i ++){
					var thisDataPt = datasetVictims[i];
					geometry.colors[i] = colorReportDate(thisDataPt);
				}
				// UPDATE UI HERE
				updateUiColorReportDate();
			});
		}

		// #############################################################################
		// ##################### THREE JS INITIALIZATION ###############################
		// #############################################################################

		function init() {
			// Tell Three JS where it will be on the webpage
			container = document.createElement( 'div' );
			document.body.appendChild( container );
			// Try to make camera and padding 0 and move the camera positon to center the grid
			if(viewSize == 800){
				horizPadding = 80;
				vertPadding = 40;
				horizAdjust4center = 10;
			} else {
				horizPadding = 0;
				vertPadding = 0;
				horizAdjust4center = 35;
			};
			// Create a Three JS camera and position it to look at our viz
			camera = new THREE.OrthographicCamera(-aspectRatio * viewSize / 2 -horizPadding, aspectRatio * viewSize / 2 +horizPadding, viewSize/2+vertPadding, viewSize/ -2-vertPadding, -100, 100);
			camera.position.x = myWidth/2-horizAdjust4center;
			camera.position.y = myHeight/2-dataPadding/2;
			camera.position.z = 1;
			// Initialize the scene that will hold our geometry
			scene = new THREE.Scene();
			// We must bind the data to geometry - the geometry itself cannot be visualized without being assigned a material
			// (later in code), but it holds valuable data like the position of each data point
			geometry = new THREE.Geometry();
			// For each data point, create a vertex and a color
			// For the intial data load we abritrarily set the data to sort to report date XY positions and
			// we assign the color to be based off of the color key
			for ( i = 0; i < datasetVictims.length; i ++ ) {
				thisDataPt = datasetVictims[i];
				var xyCoord = getXYCoordinates(thisDataPt.key, myWidth, myHeight);
				var vertex = new THREE.Vector3();
				vertex.startPosition = new THREE.Vector3(xyCoord[0], xyCoord[1], 0);
				xyCoord = getXYCoordinates(thisDataPt.uniqueRank_event_date, myWidth, myHeight);
				vertex.endPosition = new THREE.Vector3(xyCoord[0], xyCoord[1], 0);
				vertex.direction = vertex.startPosition.clone().sub(vertex.endPosition);
				vertex.copy(vertex.startPosition);
				geometry.vertices.push( vertex );
				colors[i] = colorActor(thisDataPt);
			}
			// Assign our desired color to each piece of geometry
			geometry.colors = colors;
			// For each datapoint we asign a point material with a rectangle (pixel) size and our desired color
			material = new THREE.PointsMaterial({size: rectSize, sizeAttenuation: false, vertexColors: THREE.VertexColors});
			// We now bind the geometry to the material to create a point that can be visualized, and then add those points to the scene
			particles = new THREE.Points(geometry, material);
			scene.add(particles);
			// Create a mesh sphere that we place over the datapoint that the users mouse is hovering on
			var sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
			var sphereMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, shading: THREE.FlatShading } );
			sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
			// bind the geometry to the material and create a mesh
			scene.add(sphere);
			// add this mesh to the scene
			// In order to handle mouseover events we create a raycaster and a threshold
			// from the camera's POV, whenever the mouse comes within our threshold of a given location
			// we will want to get this mouse over position and the associated point's data to display to the suer
			raycaster = new THREE.Raycaster();
			raycaster.params.Points.threshold = threshold;
			// To actually render the scene we execute the following
			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize(myWidth, myHeight);
			container.appendChild( renderer.domElement );
			// Displays our framerate in the ULH corner
			// Event listeners that listen for when the mouse is moved or when the window is resized
			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			// For user friendliness, we identify how we are sorting and coloring to begin by showing the appropriate legend and color
			updateUiSortEventDate();
			updateUiColorActor();
		}

		// #############################################################################
		// ######################## THREE JS DOCUMENT EVENTS ###########################
		// #############################################################################

		// function onWindowResize() {
		// 	//Variables to update whenever the browser window is resized
		// 	// console.log("Window resized");
		// 	windowHalfX = window.innerWidth / 2;
		// 	windowHalfY = window.innerHeight / 2;
		// 	camera.aspect = window.innerWidth / window.innerHeight;
		// 	aspectRatio = window.innerWidth / window.innerHeight;
		// 	camera.left   = - camViewSize * aspectRatio / 2;
		// 	camera.right  =   camViewSize * aspectRatio / 2;
		// 	camera.top    =   camViewSize / 2 + vertPadding;
		// 	camera.bottom = - camViewSize / 2 + vertPadding;
		// 	camera.updateProjectionMatrix();
		// 	// myHeight = viewSize;
		// 	// myWidth = viewSize*aspectRatio;
		// 	renderer.setSize( window.innerWidth, window.innerHeight );
		// }
		function onDocumentMouseMove( event ) {
			//Update our mouse x and y position whenever the mouse moves
			event.preventDefault();
			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
		}

		// #############################################################################
		// ############################ COLOR FUNCTIONS ###############################
		// #############################################################################

		// Rules to color each parameter given a datapoint
		function colorKey (_thisDataPt) {
			var gradientLength = 255;
			return new THREE.Color("rgb(100, " + _thisDataPt.key%gradientLength + ", 100)");
		}
		function colorHecho (_thisDataPt) {
			//HEX COLORS Processing consistent
			var _color1 = new THREE.Color("#e65c00");
			var _color2 = new THREE.Color("#00e6bc");
			var _color3 = new THREE.Color("#3781d1");
			var _color4 = new THREE.Color("#595959");
			if(_thisDataPt.param_hecho == 5) {
				return _color1;
			}
			else if(_thisDataPt.param_hecho == 6) {
				return _color2;
			}
			else if(_thisDataPt.param_hecho == 2) {
				return _color3;
			}
			else {
				return _color4;
			}
		}
		function colorActor (_thisDataPt) {
			//Hex Colors Processing Consistent
			var _color1 = new THREE.Color('#e128aa');
			var _color2 = new THREE.Color('#aae128');
			var _color3 = new THREE.Color('#28aae1');
			var _color4 = new THREE.Color('#595959');
			if (_thisDataPt.autor_guerrillas == 1) {
				return _color1;
			}
			else if(_thisDataPt.autor_paramilitares == 1) {
				return _color2;
			}
			else if(_thisDataPt.autor_fuerza_publica == 1) {
				return _color3;
			} 
			else {
				return _color4;
			}
		}
		function colorGender (_thisDataPt) {
			//Hex Colors Processing Consistent
			var _color1 = new THREE.Color('#421800');
			var _color2 = new THREE.Color('#013f34');
			var _color4 = new THREE.Color('#11253e');
			if(_thisDataPt.genero_hom == "Hombre") {
				return _color1;
			}
			else if(_thisDataPt.genero_hom == "Mujer") {
				return _color2;
			}
			else {
				return _color4;
			}
		}
		function colorRace (_thisDataPt) {
			//Hex Colors Processing Consistent
			var _color1 = new THREE.Color("#2db370");
			var _color2 = new THREE.Color("#b3842d");
			var _color3 = new THREE.Color("#842db3");
			var _color4 = new THREE.Color("#595959");
			if(_thisDataPt.pert_etnica == "None") {
				return _color1;
			}
			else if(_thisDataPt.pert_etnica == "Afrocolombian") {
				return _color2;
			}
			else if(_thisDataPt.pert_etnica == "Indigenous") {
				return _color3;
			}
			else {
				return _color4;
			}	
		}
		function colorEventDate (_thisDataPt) {
			var gradientLength = datasetVictims.length;;
			var thisColor = parseInt(map_range(_thisDataPt.uniqueRank_event_date, 0, datasetVictims.length, 0, 255));
			return new THREE.Color("rgb(100, " + thisColor + ", 100)");
		}
		function colorReportDate (_thisDataPt) {
			var gradientLength = datasetVictims.length;;
			var thisColor = parseInt(map_range(_thisDataPt.uniqueRank_report_date, 0, datasetVictims.length, 0, 255));
			return new THREE.Color("rgb(" + thisColor + ", 100, 100)");
		}
		function getTooltipText (_thisDataPt) {
			//Parse Text For ToolTip Mousover
			var textList = ["Date: ", "Event: ", "Actor: ", "Gender: ", "Ethnicity: "];
			textList[0] = textList[0] + _thisDataPt.f_ocurrencia_hecho.slice(0, -5);
			//Parse event data into text
			if(_thisDataPt.param_hecho == 5) {
				var _eventText = "Displacement";
			}
			else if(_thisDataPt.param_hecho == 6) {
				var _eventText = "Homocide / Massacre";
			}
			else if(_thisDataPt.param_hecho == 2) {
				var _eventText = "Threat";
			}
			else {
				var _eventText = "Other";
			}
			textList[1] = textList[1] + _eventText;
			// Parse actor data  into text
			if (_thisDataPt.autor_guerrillas == 1) {
				var _actorText = "Guerrillas";
			}
			else if(_thisDataPt.autor_paramilitares == 1) {
				var _actorText = "Paramilitaries";
			}
			else if(_thisDataPt.autor_fuerza_publica == 1) {
				var _actorText = "Armed Forces";
			} 
			else {
				var _actorText = "Other or Non-Identified";
			}
			textList[2] = textList[2] + _actorText;
			textList[3] = textList[3] + _thisDataPt.genero_hom;
			textList[4] = textList[4] + _thisDataPt.pert_etnica;
			return textList;
		}

		// #############################################################################
		// ##################### THREE JS ANIMATION  AND RENDER ########################
		// #############################################################################

		function resetAnimation() {
			//Function that we call to reset the animation
			// turn off the raycaster while the viz is transitioning to reduce burden on browser
			raycastOn = false;

			// Reset our countdown timer - this timer is what enables the particles to slide along their
			// initial position to their final position
			currentTime = duration;
		}
		//Time delta to track time passed
		var delta;
		function animate() {
			//Function attempts to run 60 FPS to run our Viz smoothly
			delta = clock.getDelta();
			currentTime -= delta;
			if(currentTime < 0) {
				// currentTime is less than 0 so any user defined sort has finished
				// reset our currenTime to 0 since it is already negative
				currentTime = 0;
				// Since the particles are not moving we want to calculate raytracing and mouseover				 
				raycastOn = true;
			}
			// Three JS request the animation frame
			requestAnimationFrame( animate );
			// Moves the particles from their initial positin to their final position
			// Note that once the particles arrive in the user defined sort positoins, after a sort is complete
			// (inital position) = (final position) and the length of the vector is 0 so the particles do not move
			geometry.vertices.forEach(function(vertex){
				vertex.addVectors(vertex.endPosition,vertex.direction.clone().multiplyScalar(currentTime / duration));
			});
			// Tells Three JS that we should update the geometries verticies (position on screen) and their color
			// for every frame we display
			geometry.verticesNeedUpdate = true;
			geometry.colorsNeedUpdate = true;
			// Tell Three JS to redner the scene and update our stats
			render();
		}
		function render() {
			//Find where the event is in world coordinates
			worldX = parseInt(map_range(mouse.x, -1, 1, 0, windowHalfX*2));
			worldY = parseInt(map_range(mouse.y, -1, 1, windowHalfY*2, 0));
			//Calculate raycaster intersections (mouseover events) when we are not actively moving particles on screen
			if (raycastOn) {
				// Tell three JS where we are drawing our ray from and based on what point
				raycaster.setFromCamera( mouse, camera );
				// Calculate what paricles if any the raycaster intersects
				var intersections = raycaster.intersectObject(particles);
				intersection = (intersections.length) > 0 ? intersections[0] : null;
				if(intersection != null) {
					// In the event that we DO intersect a particle, intersection is not null and we proceed
					// Find intersection point so we know where to display our div
					var intersectPosition = intersection.point;
					var divXLoc = worldX;
					if (divXLoc > windowHalfX) {
						divXLoc = divXLoc - 250;
					} else {
						divXLoc = divXLoc + 50;
					}
					var divYLoc = worldY;
					if (divYLoc > windowHalfY) {
						divYLoc = divYLoc - 100;
					}
					//Move our sphere to the intersected poisition
					sphere.position.copy(intersectPosition);
					sphere.visible = true;
					sphere.scale.set(2, 2, 2);
					//Get this data points parameters as text to display in the tool tip
					tooltipTextList = getTooltipText(datasetVictims[intersection.index])
					// Tell d3 where to display our tooltip
					d3.select("#tooltip")
					.transition()
					.duration(100)
					.style("left", divXLoc + "px")
					//eventually should scale the x,y so it is the same size as the space where the pixels are displayed
					.style("top", divYLoc + "px");
					d3.select("#dateText")
					.text(tooltipTextList[0]);						
					d3.select("#tooltip")
					.select("#eventText")
					.text(tooltipTextList[1]);
					d3.select("#tooltip")
					.select("#actorText")
					.text(tooltipTextList[2]);
					d3.select("#tooltip")
					.select("#genderText")
					.text(tooltipTextList[3]);
					d3.select("#tooltip")
					.select("#ethnicityText")
					.text(tooltipTextList[4]);
					//Show the tooltip
					d3.select("#tooltip").classed("hidden", false);
				} else {
					//Hide our sphere cursor
					sphere.visible = false;
					//Hide the tooltip
					d3.select("#tooltip").classed("hidden", true);
				}
			} else {
				//Hide the tooltip
				d3.select("#tooltip").classed("hidden", true);
			}
			// Three JS render this scene with this camera
			renderer.render( scene, camera );
		}
		//Update UI Elements
		function updateUiSortKey() {
			// Update a/o buttons
			d3.select("#sortHecho")
			.style("background-color", buttonColorOff);
			d3.select("#sortActor")
			.style("background-color", buttonColorOff);
			d3.select("#sortGender")
			.style("background-color", buttonColorOff);
			d3.select("#sortRace")
			.style("background-color", buttonColorOff);
			d3.select("#sortEventDate")
			.style("background-color", buttonColorOff);
			d3.select("#sortReportDate")
			.style("background-color", buttonColorOff);
			//Update this button
			d3.select("#sortKey")
			.style("background-color", buttonColorOn);
			//Hide the timelines if any show
			d3.selectAll(".timeline").classed("hidden", true);
			//Hide the ticks if any show
			d3.selectAll(".timelineTick").classed("hidden", true);
		}
		function updateUiSortHecho() {
			// Update a/o buttons
			d3.select("#sortKey")
			.style("background-color", buttonColorOff);
			d3.select("#sortActor")
			.style("background-color", buttonColorOff);
			d3.select("#sortGender")
			.style("background-color", buttonColorOff);
			d3.select("#sortRace")
			.style("background-color", buttonColorOff);
			d3.select("#sortEventDate")
			.style("background-color", buttonColorOff);
			d3.select("#sortReportDate")
			.style("background-color", buttonColorOff);
			//Update this button
			d3.select("#sortHecho")
			.style("background-color", buttonColorOn);
			//Hide the timelines if any show
			d3.selectAll(".timeline").classed("hidden", true);
			//Hide the ticks if any show
			d3.selectAll(".timelineTick").classed("hidden", true);
		}
		function updateUiSortActor() {
			// Update a/o buttons
			d3.select("#sortKey")
			.style("background-color", buttonColorOff);
			d3.select("#sortHecho")
			.style("background-color", buttonColorOff);
			d3.select("#sortGender")
			.style("background-color", buttonColorOff);
			d3.select("#sortRace")
			.style("background-color", buttonColorOff);
			d3.select("#sortEventDate")
			.style("background-color", buttonColorOff);
			d3.select("#sortReportDate")
			.style("background-color", buttonColorOff);
			//Update this button
			d3.select("#sortActor")
			.style("background-color", buttonColorOn);
			//Hide the timelines if any show
			d3.selectAll(".timeline").classed("hidden", true);
			//Hide the ticks if any show
			d3.selectAll(".timelineTick").classed("hidden", true);
		}
		function updateUiSortGender() {
			// Update a/o buttons
			d3.select("#sortKey")
			.style("background-color", buttonColorOff);
			d3.select("#sortHecho")
			.style("background-color", buttonColorOff);
			d3.select("#sortActor")
			.style("background-color", buttonColorOff);
			d3.select("#sortRace")
			.style("background-color", buttonColorOff);
			d3.select("#sortEventDate")
			.style("background-color", buttonColorOff);
			d3.select("#sortReportDate")
			.style("background-color", buttonColorOff);
			//Update this button
			d3.select("#sortGender")
			.style("background-color", buttonColorOn);
			//Hide the timelines if any show
			d3.selectAll(".timeline").classed("hidden", true);
			//Hide the ticks if any show
			d3.selectAll(".timelineTick").classed("hidden", true);
		}
		function updateUiSortRace() {
			// Update a/o buttons
			d3.select("#sortKey")
			.style("background-color", buttonColorOff);
			d3.select("#sortHecho")
			.style("background-color", buttonColorOff);
			d3.select("#sortActor")
			.style("background-color", buttonColorOff);
			d3.select("#sortGender")
			.style("background-color", buttonColorOff);
			d3.select("#sortEventDate")
			.style("background-color", buttonColorOff);
			d3.select("#sortReportDate")
			.style("background-color", buttonColorOff);
			//Update this button
			d3.select("#sortRace")
			.style("background-color", buttonColorOn);
			//Hide the timelines if any show
			d3.selectAll(".timeline").classed("hidden", true);
			//Hide the ticks if any show
			d3.selectAll(".timelineTick").classed("hidden", true);
		}
		function updateUiSortEventDate() {
			// Update a/o buttons
			d3.select("#sortKey")
			.style("background-color", buttonColorOff);
			d3.select("#sortHecho")
			.style("background-color", buttonColorOff);
			d3.select("#sortActor")
			.style("background-color", buttonColorOff);
			d3.select("#sortGender")
			.style("background-color", buttonColorOff);
			d3.select("#sortRace")
			.style("background-color", buttonColorOff);
			d3.select("#sortReportDate")
			.style("background-color", buttonColorOff);
			//Update this button
			d3.select("#sortEventDate")
			.style("background-color", buttonColorOn);
			//Show the event timeline
			d3.selectAll(".timeline#event").classed("hidden", false);
			//Show the timeline event ticks
			d3.selectAll(".timelineTick#event").classed("hidden", false);
			//Hide the other timeline
			d3.selectAll(".timeline#report").classed("hidden", true);
			//Hide the timeline event ticks
			d3.selectAll(".timelineTick#report").classed("hidden", true);
		}
		function updateUiSortReportDate() {
			// Update a/o buttons
			d3.select("#sortKey")
			.style("background-color", buttonColorOff);
			d3.select("#sortHecho")
			.style("background-color", buttonColorOff);
			d3.select("#sortActor")
			.style("background-color", buttonColorOff);
			d3.select("#sortGender")
			.style("background-color", buttonColorOff);
			d3.select("#sortRace")
			.style("background-color", buttonColorOff);
			d3.select("#sortEventDate")
			.style("background-color", buttonColorOff);
			//Update this button
			d3.select("#sortReportDate")
			.style("background-color", buttonColorOn);
			//Show the report timeline
			d3.selectAll(".timeline#report").classed("hidden", false);
			//Show the timeline event ticks
			d3.selectAll(".timelineTick#report").classed("hidden", false);
			//Hide the other timeline
			d3.selectAll(".timeline#event").classed("hidden", true);
			//Hide the timeline event ticks
			d3.selectAll(".timelineTick#event").classed("hidden", true);
		}

		function updateUiColorKey() {
			//Update legend text
			d3.select("#legend01Text")
			.text("");
			d3.select("#legend02Text")
			.text("");
			d3.select("#legend03Text")
			.text("");
			d3.select("#legend04Text")
			.text("Coloring by Key");
			//Update legend rectangels
			d3.select("#legendRect01")
			.style("background-color", "#000000");
			d3.select("#legendRect02")
			.style("background-color", "#000000");
			d3.select("#legendRect03")
			.style("background-color", "#000000");
			d3.select("#legendRect04")
			.style("background-color", "#fff");
			//Update a/o color buttons
			d3.select("#colorHecho")
			.style("background-color", buttonColorOff);
			d3.select("#colorActor")
			.style("background-color", buttonColorOff);
			d3.select("#colorGender")
			.style("background-color", buttonColorOff);
			d3.select("#colorRace")
			.style("background-color", buttonColorOff);
			d3.select("#colorEventDate")
			.style("background-color", buttonColorOff);
			d3.select("#colorReportDate")
			.style("background-color", buttonColorOff);
			//Update this color button
			d3.select("#colorKey")
			.style("background-color", buttonColorOn);
		}
		function updateUiColorHecho() {
			//Update legend text
			d3.select("#legend01Text")
			.text("Displacement");
			d3.select("#legend02Text")
			.text("Homicide / Massacre");
			d3.select("#legend03Text")
			.text("Threat");
			d3.select("#legend04Text")
			.text("Other");
			//Update legend rectangels
			d3.select("#legendRect01")
			.style("background-color", "#e65c00");
			d3.select("#legendRect02")
			.style("background-color", "#00e6bc");
			d3.select("#legendRect03")
			.style("background-color", "#3781d1");
			d3.select("#legendRect04")
			.style("background-color", "#595959");
			//Update a/o color buttons
			d3.select("#colorKey")
			.style("background-color", buttonColorOff);
			d3.select("#colorActor")
			.style("background-color", buttonColorOff);
			d3.select("#colorGender")
			.style("background-color", buttonColorOff);
			d3.select("#colorRace")
			.style("background-color", buttonColorOff);
			d3.select("#colorEventDate")
			.style("background-color", buttonColorOff);
			d3.select("#colorReportDate")
			.style("background-color", buttonColorOff);
			//Update this color button
			d3.select("#colorHecho")
			.style("background-color", buttonColorOn);
		}
		function updateUiColorActor() {
			//Update legend
			d3.select("#legend01Text")
			.text("Guerrillas");
			d3.select("#legend02Text")
			.text("Paramilitaries");
			d3.select("#legend03Text")
			.text("Armed Forces");
			d3.select("#legend04Text")
			.text("Other or Non-Identified");
			//Update legend rectangels
			d3.select("#legendRect01")
			.style("background-color", "#e128aa");
			d3.select("#legendRect02")
			.style("background-color", "#aae128");
			d3.select("#legendRect03")
			.style("background-color", "#28aae1");
			d3.select("#legendRect04")
			.style("background-color", "#595959");
			//Update a/o color buttons
			d3.select("#colorKey")
			.style("background-color", buttonColorOff);
			d3.select("#colorHecho")
			.style("background-color", buttonColorOff);
			d3.select("#colorGender")
			.style("background-color", buttonColorOff);
			d3.select("#colorRace")
			.style("background-color", buttonColorOff);
			d3.select("#colorEventDate")
			.style("background-color", buttonColorOff);
			d3.select("#colorReportDate")
			.style("background-color", buttonColorOff);
			//Update this color button
			d3.select("#colorActor")
			.style("background-color", buttonColorOn);
		}
		function updateUiColorGender() {
			//Update legend text
			d3.select("#legend01Text")
			.text("");
			d3.select("#legend02Text")
			.text("Male");
			d3.select("#legend03Text")
			.text("Female");
			d3.select("#legend04Text")
			.text("Other or N/A");
			//Update legend rectangels
			d3.select("#legendRect01")
			.style("background-color", "#000000");
			d3.select("#legendRect02")
			.style("background-color", "#421800");
			d3.select("#legendRect03")
			.style("background-color", "#013f34");
			d3.select("#legendRect04")
			.style("background-color", "#11253e");
			//Update a/o color buttons
			d3.select("#colorKey")
			.style("background-color", buttonColorOff);
			d3.select("#colorHecho")
			.style("background-color", buttonColorOff);
			d3.select("#colorActor")
			.style("background-color", buttonColorOff);
			d3.select("#colorRace")
			.style("background-color", buttonColorOff);
			d3.select("#colorEventDate")
			.style("background-color", buttonColorOff);
			d3.select("#colorReportDate")
			.style("background-color", buttonColorOff);
			//Update this color button
			d3.select("#colorGender")
			.style("background-color", buttonColorOn);
		}

		function updateUiColorRace() {
			//Update legend text
			d3.select("#legend01Text")
			.text("N/A");
			d3.select("#legend02Text")
			.text("Afrocolombian");
			d3.select("#legend03Text")
			.text("Indigenous");
			d3.select("#legend04Text")
			.text("Other");
			//Update legend rectangels
			d3.select("#legendRect01")
			.style("background-color", "#2db370");
			d3.select("#legendRect02")
			.style("background-color", "#b3842d");
			d3.select("#legendRect03")
			.style("background-color", "#842db3");
			d3.select("#legendRect04")
			.style("background-color", "#595959");
			//Update a/o color buttons
			d3.select("#colorKey")
			.style("background-color", buttonColorOff);
			d3.select("#colorHecho")
			.style("background-color", buttonColorOff);
			d3.select("#colorActor")
			.style("background-color", buttonColorOff);
			d3.select("#colorGender")
			.style("background-color", buttonColorOff);
			d3.select("#colorEventDate")
			.style("background-color", buttonColorOff);
			d3.select("#colorReportDate")
			.style("background-color", buttonColorOff);
			//Update this color button
			d3.select("#colorRace")
			.style("background-color", buttonColorOn);
		}
		function updateUiColorEventDate() {
			// //Update legend text
			d3.select("#legend01Text")
			.text("");
			d3.select("#legend02Text")
			.text("");
			d3.select("#legend03Text")
			.text("1985");
			d3.select("#legend04Text")
			.text("2015");
			//Update legend rectangels
			d3.select("#legendRect01")
			.style("background-color", "#000000");
			d3.select("#legendRect02")
			.style("background-color", "#000000");
			d3.select("#legendRect03")
			.style("background-color",  "#650065");
			d3.select("#legendRect04")
			.style("background-color", "#5cff5a" );
			//Update a/o color buttons
			d3.select("#colorKey")
			.style("background-color", buttonColorOff);
			d3.select("#colorHecho")
			.style("background-color", buttonColorOff);
			d3.select("#colorActor")
			.style("background-color", buttonColorOff);
			d3.select("#colorGender")
			.style("background-color", buttonColorOff);
			d3.select("#colorRace")
			.style("background-color", buttonColorOff);
			d3.select("#colorReportDate")
			.style("background-color", buttonColorOff);
			//Update this color button
			d3.select("#colorEventDate")
			.style("background-color", buttonColorOn);
		}
		function updateUiColorReportDate() {
			//Update legend text
			d3.select("#legend01Text")
			.text("");
			d3.select("#legend02Text")
			.text("");
			d3.select("#legend03Text")
			.text("1990");
			d3.select("#legend04Text")
			.text("2016");
			//Update legend rectangels
			d3.select("#legendRect01")
			.style("background-color", "#000000");
			d3.select("#legendRect02")
			.style("background-color", "#000000");
			d3.select("#legendRect03")
			.style("background-color", "#006465");
			d3.select("#legendRect04")
			.style("background-color", "#ff6360");
			//Update a/o color buttons
			d3.select("#colorKey")
			.style("background-color", buttonColorOff);
			d3.select("#colorHecho")
			.style("background-color", buttonColorOff);
			d3.select("#colorActor")
			.style("background-color", buttonColorOff);
			d3.select("#colorGender")
			.style("background-color", buttonColorOff);
			d3.select("#colorRace")
			.style("background-color", buttonColorOff);
			d3.select("#colorEventDate")
			.style("background-color", buttonColorOff);
			//Update this color button
			d3.select("#colorReportDate")
			.style("background-color", buttonColorOn);
		}
		//Given a data index return the x and y coordinates in the array
		function getXYCoordinates(_thisIndex, _width, _height) {
			//Sorting from top to bottom, starting at upper left hand corner
			maxHeight = _height - (_height%(rectSize+rectSpacerH)) - dataPadding;
			var myList = [];
			myList[0] = parseInt( ( (1+_thisIndex) * (rectSize+rectSpacerH) ) / maxHeight ) * (rectSpacerW+rectSize)
			myList[1] = parseInt(maxHeight - (_thisIndex*(rectSize+rectSpacerH))%maxHeight)
			return myList;
		}
		//Map values
		function map_range(value, low1, high1, low2, high2) {
			return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
		}
	</script>
</body>
</html>
